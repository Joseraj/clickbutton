#labels Featured,Phase-Implementation
#Installing and usage of the ClickButton library

= Installing =

For Arduino 0017 onwards, just extract the contents of the archive into the "libraries" folder located in the sketchbook folder.


= Syntax =
{{{
ClickButton buttonObject(pin [,active [,CLICKBTN_PULLUP]]);
}}}

where:
 * pin is the pin connected to the button
 * active denotes an active LOW or HIGH button (default is LOW)
 * CLICKBTN_PULLUP turns on the internal pullup resistor. This is only possible with active low buttons.


== Functions ==

Only one function:

{{{buttonObject.Update();}}}

Which reads the button, and updates it's click codes. This should basically be read once each main program loop.

Note that the click code is lost shortly after the button is released and the Update() function is called.


== Public variables / members ==

{{{buttonObject.depressed}}} - the currently debounced button (press) state
{{{buttonObject.maxPresses}}} - Max nr. of multiclicks allowable
{{{buttonObject.debounceTime}}} - Sets the time limit for ignoring button bounces
{{{buttonObject.multiclickTime}}} - Sets / gets the time limit for multiple clicks
{{{buttonObject.heldDownTime}}} - Sets the time limit for a "held-down" button event. 


{{{buttonObject.click}}}

Click code depending on button presses / clicks

=== Returned click codes: ===

 * A positive numbers returns the number of clicks, after a released button
 * A negative number also returns the number of clicks, but after the button is held down for a time (default 1 second).

*Note* These clickcodes are *opposite* of the previous versions. I changed them since I thought it made more sense, and since I removed the immediate held-down click-counts.

Another *opposite* is that the returned click codes are now basically reset between button update() calls (depending on the button clicks and time of reading them), but one should still save the click codes received. See examples.


= Example =

This example is included in the library, as well as another one.

Using an active-low button, and using the internal pull-up resistor of the atmega chip:

{{{

#include "ClickButton.h"

// the LED
const int ledPin = 10;
int ledState = 0;

// the Button
const int buttonPin1 = 4;
ClickButton button1(buttonPin1, LOW, CLICKBTN_PULLUP);

// Arbitrary LED function 
int LEDfunction = 0;


void setup()
{
  pinMode(ledPin,OUTPUT);  

  // Setup button timers (all in milliseconds / ms)
  // (These are default if not set, but changeable for convenience)
  button1.maxPresses     = 3;    // max button multiclick count
  button1.debounceTime   = 20;   // Debounce timer in ms
  button1.multiclickTime = 250;  // Time limit for multi clicks
  button1.heldDownTime   = 1000; // time until "held-down clicks" register
}


void loop()
{
  // Update button state
  button1.Update();

  // Save click codes in LEDfunction, as click codes are reset at next Update()
  if (button1.click != 0) LEDfunction = button1.click;
  

  // Simply toggle LED on single clicks
  // (Cant use LEDfunction like the others here,
  //  as it would toggle on and off all the time)
  if(button1.click == 1) ledState = !ledState;

  // blink faster if double clicked
  if(LEDfunction == 2) ledState = (millis()/500)%2;

  // blink even faster if triple clicked
  if(LEDfunction == 3) ledState = (millis()/200)%2;

  // slow blink (must hold down button. 1 second long blinks)
  if(LEDfunction == -1) ledState = (millis()/1000)%2;

  // slower blink (must hold down button. 2 second loong blinks)
  if(LEDfunction == -2) ledState = (millis()/2000)%2;

  // even slower blink (must hold down button. 3 second looong blinks)
  if(LEDfunction == -3) ledState = (millis()/3000)%2;


  // update the LED
  digitalWrite(ledPin,ledState);

}

}}}